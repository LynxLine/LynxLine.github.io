<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LynxLine</title>
    <link>https://lynxline.com/</link>
    <description>Recent content on LynxLine</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 08 Mar 2024 10:10:11 +0100</lastBuildDate>
    <atom:link href="https://lynxline.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Services</title>
      <link>https://lynxline.com/services/</link>
      <pubDate>Fri, 08 Mar 2024 10:10:11 +0100</pubDate>
      <guid>https://lynxline.com/services/</guid>
      <description>Introducing LynxLine. Our team specializes in creating secure and efficient solutions for businesses and organizations. With a focus on cutting-edge technology and unparalleled expertise, we are dedicated to providing top-notch services to protect your sensitive data and communications.&#xA;Smart contracts audit Our industry-leading veteran smart contract auditors, ensures that your Ethereum application is ready for launch and built to protect users.&#xA;Software development Our expertise lies in designing and developing software for networking and desktop applications, high-availability servers, and optimizing application performance.</description>
    </item>
    <item>
      <title>Contact</title>
      <link>https://lynxline.com/contact/</link>
      <pubDate>Wed, 06 Mar 2024 21:50:35 +0100</pubDate>
      <guid>https://lynxline.com/contact/</guid>
      <description>BM-2cWzqxBQpnKuu8QhLjep1YsRdhCL9mLeTc</description>
    </item>
    <item>
      <title>Init</title>
      <link>https://lynxline.com/posts/first_post/</link>
      <pubDate>Sun, 03 Mar 2024 11:21:28 +0100</pubDate>
      <guid>https://lynxline.com/posts/first_post/</guid>
      <description>init</description>
    </item>
    <item>
      <title>Lab 9, coding assembler part</title>
      <link>https://lynxline.com/posts/lab-9-coding-assembler-part/</link>
      <pubDate>Sun, 27 Jan 2013 21:59:03 +0200</pubDate>
      <guid>https://lynxline.com/posts/lab-9-coding-assembler-part/</guid>
      <description>Time to have assembler part of Inferno kernel to be implemented. Let’s start with routines that allows to make labels and later jump to them, they are used in kernel sources to have scheduler to switch control and do context switching between processes. The Label structure in dat.h:&#xA;1struct Label { 2&#x9;ulong sp; 3&#x9;ulong pc; 4}; Simple idea to remember the PC(program counter) and SP(stack pointer), to init the structure and use later, we should have two functions implemented:</description>
    </item>
    <item>
      <title>Lab 8, memory model</title>
      <link>https://lynxline.com/posts/lab-8-memory-model/</link>
      <pubDate>Thu, 24 Jan 2013 20:18:59 +0200</pubDate>
      <guid>https://lynxline.com/posts/lab-8-memory-model/</guid>
      <description>Now time to have a look at memory model. The BCM2835 gives next picture:&#xA;Actually when U-Boot pass the control, we have memory model equal to just physical addresses (middle column), so we just do not do anything we can perfectly sit with memory model equal with physical.&#xA;So then, our kernel is loaded at 0x8000, which is 32KB, and we are going to use the low 0-0x8000 memory part for kernel structures and kernel stack (which is not expected to be too much)</description>
    </item>
    <item>
      <title>Lab 7, linking, planning next</title>
      <link>https://lynxline.com/posts/lab-7-linking-more-initialization/</link>
      <pubDate>Mon, 17 Dec 2012 21:07:59 +0200</pubDate>
      <guid>https://lynxline.com/posts/lab-7-linking-more-initialization/</guid>
      <description>As we have the kernel almost compiled now it is time to check what is missing to have it linked. By checking header files and adding stubs into main.c we will get linked with very small changes as:&#xA;Changes to main.c:&#xA;1#include &amp;#34;u.h&amp;#34; 2#include &amp;#34;../port/lib.h&amp;#34; 3#include &amp;#34;dat.h&amp;#34; 4#include &amp;#34;mem.h&amp;#34; 5 6Conf conf; 7Mach *m = (Mach*)MACHADDR; 8Proc *up = 0; 9 10#include &amp;#34;../port/uart.h&amp;#34; 11PhysUart* physuart[1]; 12 13int waserror(void) { return 0; } 14int splhi(void) { return 0; } 15void splx(int) { return; } 16int spllo(void) { return 0; } 17void splxpc(int) { return; } 18int islo(void) { return 0; } 19int setlabel(Label*) { return 0; } 20void gotolabel(Label*) { return; } 21ulong getcallerpc(void*) { return 0; } 22int segflush(void*, ulong) { return 0; } 23void idlehands(void) { return; } 24void kprocchild(Proc *p, void (*func)(void*), void *arg) { return; } 25ulong _tas(ulong*) { return 0; } 26ulong _div(ulong*) { return 0; } 27ulong _divu(ulong*) { return 0; } 28ulong _mod(ulong*) { return 0; } 29ulong _modu(ulong*) { return 0; } 30 31void setpanic(void) { return; } 32void dumpstack(void) { return; } 33void exit(int) { return; } 34void reboot(void) { return; } 35void halt(void) { return; } 36 37Timer* addclock0link(void (*)(void), int) { return 0; } 38void clockcheck(void) { return; } 39 40void fpinit(void) {} 41void FPsave(void*) {} 42void FPrestore(void*) {} Changes to fns.</description>
    </item>
    <item>
      <title>Lab 6, Compile something</title>
      <link>https://lynxline.com/posts/lab-6-compile-something/</link>
      <pubDate>Tue, 11 Dec 2012 22:05:20 +0200</pubDate>
      <guid>https://lynxline.com/posts/lab-6-compile-something/</guid>
      <description>Now it is lab 6 and it is time to compile “something” – kernel of inferno, but we are going to compile without worrying that it would not work (even would not link). We just need inferno kernel which can be compiled okay for R-Pi using a lot of stabs.&#xA;Files/Folders structure:&#xA;inferno-os/ |-os/ | |-rpi/ | | |-rpi | | |-mkfile | | |-load.s | | |-main.c mkfile:&#xA;1&amp;lt;../../mkconfig 2 3CONF=rpi 4CONFLIST=rpi 5loadaddr=0x00008000 6 7SYSTARG=$OSTARG 8OBJTYPE=arm 9INSTALLDIR=$ROOT/Inferno/$OBJTYPE/bin 10 11&amp;lt;$ROOT/mkfiles/mkfile-$SYSTARG-$OBJTYPE 12 13&amp;lt;| $SHELLNAME .</description>
    </item>
    <item>
      <title>Lab 5, Hello World</title>
      <link>https://lynxline.com/posts/lab-5-hello-world/</link>
      <pubDate>Tue, 27 Nov 2012 22:05:20 +0200</pubDate>
      <guid>https://lynxline.com/posts/lab-5-hello-world/</guid>
      <description>This lab will be short but it is going to summarize all material provided in previous labs. Our target to develop simple “barebone” program which can be loaded and executed by U-Boot. It should only print “Hello world!” to our serial console.&#xA;First, let’s find out how we can print something. BCM2835 manual describes that the chip has different features as Mini-UART and PL011 UART.&#xA;Instead of writing own driver for UART routines let’s better check how U-Boot performs.</description>
    </item>
    <item>
      <title>Lab 4, Loading kernel</title>
      <link>https://lynxline.com/posts/lab-4-loading-kernel/</link>
      <pubDate>Sun, 18 Nov 2012 21:27:34 +0200</pubDate>
      <guid>https://lynxline.com/posts/lab-4-loading-kernel/</guid>
      <description>Time to study the way how we place our kernel into the memory on R-Pi. U-Boot have usually convention to place loaded binaries at 0x8000 (32KB) and just pass control there. So, let’s compile trivial program and study generated binary to understand the way how we can operate with it.&#xA;In Lab 1 we found a way of making ARM executables. Check what actually the file is:&#xA;$ file test test: Plan 9 executable, ARM 7-something By checking Plan 9 a.</description>
    </item>
    <item>
      <title>Lab 3, R-Pi Booting process</title>
      <link>https://lynxline.com/posts/lab-3-r-pi-booting-process/</link>
      <pubDate>Fri, 16 Nov 2012 21:18:43 +0200</pubDate>
      <guid>https://lynxline.com/posts/lab-3-r-pi-booting-process/</guid>
      <description>Now time to study the boot process on Raspberry Pi. Good source to study: R-Pi Boot process&#xA;Stage 1 boot is in the on-chip ROM. Loads stage2 in the L2 cache! Stage 2 is bootcode.bin. Enables SDRAM and loads stage3 Stage 3 is loader.bin. Knows about elf format and load start.elf start.elf loads kernel.img (also start.elf is the main gpu code). It reads config.txt, cmdline.txt and bcm2835.dtb If the dtb file exists, it is loaded at 0x100 &amp;amp; kernel @ 0x8000 Else if disable_commandline_tags is set load kernel @ 0x0 Else if load kernel @ 0x8000 and put ATAGS at 0x100 kernel.</description>
    </item>
    <item>
      <title>Lab 2, Hardware</title>
      <link>https://lynxline.com/posts/lab-2-hardware/</link>
      <pubDate>Fri, 16 Nov 2012 21:18:42 +0200</pubDate>
      <guid>https://lynxline.com/posts/lab-2-hardware/</guid>
      <description>We need to have possibility of booting kernel on Raspbery Pi. Because we will not have display driver soon, we need another approach – have serial port connected to get all output from booter and then from our kernel. We bought small FTDI 3.3V chip to have connected it to GPIO pins on one side and to USB port of my Mac on another side. Also need to install FTDIUSBSerialDriver_v2_2_18 for Mac.</description>
    </item>
    <item>
      <title>Lab 1, Compiler</title>
      <link>https://lynxline.com/posts/lab-1-compiler/</link>
      <pubDate>Fri, 16 Nov 2012 21:18:41 +0200</pubDate>
      <guid>https://lynxline.com/posts/lab-1-compiler/</guid>
      <description>Let’s start with tools that we need to just build the OS for ARM. First clone official inferno os repository from google code repository:&#xA;1# hg clone https://code.google.com/p/inferno-os/ What we need to move further? We need the ARM cross compiler, linker, etc. For this, let’s just compile inferno targeting mac as host (we are on mac now, so we will get hosted inferno for mac as result):&#xA;1# cd inferno-os/ 2# INF_ROOT=`pwd` perl -i -pe &amp;#39;s/^ROOT=.</description>
    </item>
  </channel>
</rss>
